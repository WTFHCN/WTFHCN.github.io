<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="学习笔记," />





  <link rel="alternate" href="/atom.xml" title="NaCNer" type="application/atom+xml" />






<meta name="description" content="要失业了">
<meta property="og:type" content="article">
<meta property="og:title" content="要失业了">
<meta property="og:url" content="http://yoursite.com/2020/12/31/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="NaCNer">
<meta property="og:description" content="要失业了">
<meta property="article:published_time" content="2020-12-31T02:47:00.000Z">
<meta property="article:modified_time" content="2021-01-22T11:42:29.058Z">
<meta property="article:author" content="HCN">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/12/31/面试总结/"/>





  <title>要失业了 | NaCNer</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NaCNer</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/31/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HCN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NaCNer">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">要失业了</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-31T10:47:00+08:00">
                2020-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>  阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>要失业了</p>
<a id="more"></a>
<!-- TOC -->
<ul>
<li><a href="#计算机网络">计算机网络</a><ul>
<li><a href="#osi">OSI</a></li>
<li><a href="#输入url之后">输入URL之后</a><ul>
<li><a href="#构建请求">构建请求</a></li>
</ul>
</li>
<li><a href="#tcp-ip">TCP IP</a><ul>
<li><a href="#区别">区别</a></li>
<li><a href="#tcp的可靠连接">TCP的可靠连接</a><ul>
<li><a href="#校验和">校验和：</a></li>
<li><a href="#确认应答ack机制">确认应答（ACK）机制：</a></li>
<li><a href="#超时重传">超时重传：</a></li>
<li><a href="#连接管理机制">连接管理机制</a></li>
<li><a href="#流量控制">流量控制：</a></li>
<li><a href="#拥塞控制">拥塞控制：</a></li>
<li><a href="#停止等待协议">停止等待协议</a></li>
</ul>
</li>
<li><a href="#tcp三次握手">TCP三次握手</a><ul>
<li><a href="#tcp四次握手">TCP四次握手</a></li>
</ul>
</li>
<li><a href="#为什么连接的时候是三次握手关闭的时候却是四次握手">为什么连接的时候是三次握手，关闭的时候却是四次握手？</a></li>
<li><a href="#为什么time_wait状态需要经过2msl最大报文段生存时间才能返回到close状态">为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</a></li>
<li><a href="#http">http</a></li>
</ul>
</li>
<li><a href="#http-1">HTTP</a><ul>
<li><a href="#报文构成">报文构成</a><ul>
<li><a href="#响应报文">响应报文</a></li>
</ul>
</li>
<li><a href="#http-状态码">HTTP 状态码</a></li>
<li><a href="#http10和http11的区别">HTTP1.0和HTTP1.1的区别</a></li>
<li><a href="#http-和-https-的区别">http 和 https 的区别</a><ul>
<li><a href="#https-优点-缺点">https 优点 缺点</a></li>
</ul>
</li>
<li><a href="#get和post的区别">GET和POST的区别</a></li>
</ul>
</li>
<li><a href="#ip-mac地址">IP MAC地址</a><ul>
<li><a href="#tcpip-数据链路交互过程">TCP/IP 数据链路交互过程。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#redis">redis</a><ul>
<li><a href="#与mongodb-数据库">与mongodb 数据库</a></li>
<li><a href="#数据类型">数据类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c">C++</a><ul>
<li><a href="#虚函数以及多态">虚函数以及多态</a></li>
<li><a href="#析构函数-虚函数">析构函数 虚函数</a></li>
<li><a href="#关于虚函数的常见问题">关于虚函数的常见问题</a><ul>
<li><a href="#虚函数的代价">虚函数的代价</a></li>
<li><a href="#那些函数不能是虚函数">那些函数不能是虚函数？</a></li>
<li><a href="#虚函数和纯虚函数的区别">虚函数和纯虚函数的区别？</a></li>
<li><a href="#菱形继承的内存结构如何解决菱形继承存在的问题">菱形继承的内存结构？如何解决菱形继承存在的问题？</a></li>
<li><a href="#虚析构函数的作用父类的析构函数为什么一定要设置成虚函数">虚析构函数的作用？父类的析构函数为什么一定要设置成虚函数？</a></li>
<li><a href="#构造函数和析构函数中为什么不可以调用虚函数">构造函数和析构函数中为什么不可以调用虚函数？</a></li>
<li><a href="#构造函数为什么不能为虚函数什么情况下析构函数必须为虚函数">构造函数为什么不能为虚函数？什么情况下析构函数必须为虚函数？</a></li>
</ul>
</li>
<li><a href="#字节对齐">字节对齐</a><ul>
<li><a href="#字节对齐的细节和编译器实现相关但一般而言满足三个准则">字节对齐的细节和编译器实现相关，但一般而言，满足三个准则：</a></li>
</ul>
</li>
<li><a href="#c中内存泄漏的几种情况">C++中内存泄漏的几种情况</a></li>
<li><a href="#new和malloc的区别">new和malloc的区别</a><ul>
<li><a href="#属性">属性</a></li>
<li><a href="#参数">参数</a></li>
<li><a href="#返回类型">返回类型</a></li>
<li><a href="#分配失败">分配失败</a></li>
<li><a href="#自定义类型">自定义类型</a></li>
<li><a href="#重载">重载</a></li>
<li><a href="#内存区域">内存区域</a><ul>
<li><a href="#左值和右值的区别右值引用的概念及其应用场景">左值和右值的区别，右值引用的概念及其应用场景</a></li>
</ul>
</li>
<li><a href="#左值lvalue">左值(lvalue)：</a></li>
<li><a href="#右值rvalue">右值(rvalue)：</a></li>
<li><a href="#左右值转换">左右值转换</a><ul>
<li><a href="#左值引用">左值引用</a></li>
<li><a href="#右值引用">右值引用</a></li>
</ul>
</li>
<li><a href="#右值引用的用途">右值引用的用途</a></li>
</ul>
</li>
<li><a href="#free与delete的区别">free与delete的区别</a></li>
<li><a href="#堆和栈的区别是什么">堆和栈的区别是什么</a><ul>
<li><a href="#静态函数">静态函数</a></li>
<li><a href="#类的静态成员">类的静态成员</a></li>
</ul>
</li>
<li><a href="#cast转换">cast转换</a></li>
<li><a href="#dynamic_cast">dynamic_cast</a></li>
<li><a href="#reinterpret_cast">reinterpret_cast</a></li>
<li><a href="#指针与引用">指针与引用</a></li>
<li><a href="#virtual关键字的作用">virtual关键字的作用</a></li>
<li><a href="#resize-reserve">resize reserve</a></li>
<li><a href="#智能指针">智能指针</a></li>
<li><a href="#静态函数与虚函数的区别">静态函数与虚函数的区别</a></li>
<li><a href="#重载-重写">重载 重写</a></li>
<li><a href="#虚函数和多态">虚函数和多态</a></li>
<li><a href="#newdelete-mallocfree-的区别">new/delete malloc/free 的区别</a></li>
<li><a href="#虚函数表具体是怎么实现运行时多态的">虚函数表具体是怎么实现运行时多态的？</a></li>
</ul>
</li>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#用户态与内核态">用户态与内核态</a></li>
<li><a href="#进程与线程的概念">进程与线程的概念</a><ul>
<li><a href="#进程">进程</a></li>
<li><a href="#线程">线程</a></li>
<li><a href="#区别-1">区别</a></li>
<li><a href="#进程调度算法">进程调度算法</a></li>
<li><a href="#进程间通信方式">进程间通信方式</a><ul>
<li><a href="#普通管道pipe">普通管道PIPE</a></li>
<li><a href="#命名管道fifo">命名管道FIFO</a></li>
<li><a href="#系统ipc">系统IPC</a></li>
</ul>
</li>
<li><a href="#线程间通信方式">线程间通信方式</a></li>
</ul>
</li>
<li><a href="#linux-虚拟地址空间">Linux 虚拟地址空间</a><ul>
<li><a href="#好处">好处</a></li>
</ul>
</li>
<li><a href="#代价">代价</a></li>
<li><a href="#并发-并行">并发 并行</a></li>
<li><a href="#os缺页置换算法">OS缺页置换算法</a></li>
<li><a href="#死锁">死锁</a><ul>
<li><a href="#必要条件">必要条件</a></li>
</ul>
</li>
<li><a href="#解决方法">解决方法</a></li>
<li><a href="#epoll">epoll</a></li>
<li><a href="#tcp和udp可以同时监听相同的端口吗">TCP和UDP可以同时监听相同的端口吗</a></li>
<li><a href="#cookie和session有什么区别">COOKIE和SESSION有什么区别？</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>七层划分为</p>
<ul>
<li>应用层(HTTP，FTP，DNS) 文件传输，电子邮件，文件服务，虚拟终端 </li>
<li>表示层（JPEG，ASII）数据格式化，代码转换，数据加密</li>
<li>会话层（RPC，NFS） 解除或建立与别的接点的联系</li>
<li>传输层（TCP，UDP） 提供端对端的接口</li>
<li>网络层 (IP，ARP，ICMP) 为数据包选择路由</li>
<li>数据链路层(MAC，VLAN，PPP) 传输有地址的帧以及错误检测功能</li>
<li>物理层。</li>
</ul>
<p>五层划分为：应用层、传输层、网络层、数据链路层、物理层。</p>
<p>四层划分为：应用层、传输层、网络层、网络接口层。</p>
<h2 id="输入URL之后"><a href="#输入URL之后" class="headerlink" title="输入URL之后"></a>输入URL之后</h2><ul>
<li><p>浏览器查找域名对应的IP地址<br>DNS查找过程为：<br>浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS缓存-&gt;递归搜索<br>递归搜索过程为：从根域名服务器到顶级域名服务器到你查询的域名服务器。</p>
</li>
<li><p>浏览器打开TCP连接（默认端口为80），向该IP的服务器发送一条HTTP请求，如果浏览器存储了该域名下的cookie，那么cookie也会放入http请求中</p>
</li>
<li>服务器给浏览器进行一个301永久重定向响应。该IP对应的服务器很可能是代理服务器，比如你输入“<a href="http://baidu.com”,而不是“http://www.baidu.com”,按道理这两个网址对应的是同一个网页，因此通过代理服务器的方式进行重定向相应，让这两个网址访问的是同一个网页。" target="_blank" rel="noopener">http://baidu.com”,而不是“http://www.baidu.com”,按道理这两个网址对应的是同一个网页，因此通过代理服务器的方式进行重定向相应，让这两个网址访问的是同一个网页。</a></li>
<li>TCP连接</li>
<li>浏览器根据重定向地址再次进行HTTP请求。</li>
<li>服务器分析HTTP请求，生成HTTP响应，将响应发给客户端。</li>
<li>浏览器收到响应内容之后，生成主页框架，同时向服务端继续发送请求，请求的内容是主页里的一些资源，比如说图片、视频等。</li>
<li>对于静态的页面内容，浏览器通常进行缓存，对于动态的内容通常不缓存，缓存的时间也是有期限的。</li>
<li>浏览器向服务器发送异步请求，因为有些页面显示完成之后客户端仍需要与服务端保持联系。</li>
<li>整个过程结束之后，浏览器关闭TCP连接。</li>
</ul>
<h3 id="构建请求"><a href="#构建请求" class="headerlink" title="构建请求"></a>构建请求</h3><ul>
<li>应用层进行DNS解析</li>
<li>应用层生成HTTP请求报文</li>
<li>传输层建立TCP连接 因TCP是一个可靠的传输控制协议，传输层还会加入序列号、确认号、窗口大小、校验和等参数，共添加20字节的头部信息</li>
<li>网络层使用IP协议来选择路线</li>
<li></li>
</ul>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP IP"></a>TCP IP</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>TCP是面向连接的，可靠性高，UDP是基于非连接的，可靠性低。</li>
<li>TCP三次握手延迟高，实时性较强。</li>
<li>在传输相同大小数据时，TCP首部开销大，报头更复杂，实际保护数据较少。 但TCP提供超时重传机制，保证不会出现丢包乱序。UDP有丢包。</li>
<li>TCP提供双全工通信，每条TCP的连接只能点到点。UDP支持一对多，多对一，多对多的交互通信。</li>
<li>数据链路层实现网络相邻结点间可靠的数据通信</li>
<li>物理层传输数据</li>
</ul>
<p>构建TCP请求会增加大量的网络时延，常用的优化方式如下所示</p>
<ul>
<li><p>资源打包，合并请求</p>
</li>
<li><p>多使用缓存，减少网络传输</p>
</li>
<li><p>使用keep-alive建立持久连接</p>
</li>
<li><p>使用多个域名，增加浏览器的资源并发加载数，或者使用HTTP2的管道化连接的多路复用技术</p>
</li>
</ul>
<h3 id="TCP的可靠连接"><a href="#TCP的可靠连接" class="headerlink" title="TCP的可靠连接"></a>TCP的可靠连接</h3><p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157&quot;" target="_blank" rel="noopener"></a></p>
<h4 id="校验和："><a href="#校验和：" class="headerlink" title="校验和："></a>校验和：</h4><p>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p>
<h4 id="确认应答（ACK）机制："><a href="#确认应答（ACK）机制：" class="headerlink" title="确认应答（ACK）机制："></a>确认应答（ACK）机制：</h4><p>TCP将每个字节的数据都进行了编号，即为序列号。确认序号=序号+1</p>
<p>接收方收到报文就会确认（累积确认：对所有按序接收的数据的确认）</p>
<p>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
<h4 id="超时重传："><a href="#超时重传：" class="headerlink" title="超时重传："></a>超时重传：</h4><p>报文的往返时间RTT</p>
<p>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p>
<p>如果主机A未收到B发来的确认应答，也可能是因为ACK丢了。因此主机B会收到很多重复的数据，那么，TCP协议需要能够识别出那些包是重复的包，并且把重复的包丢弃，这时候我们可以用前面提到的序列号，很容易做到去重的效果</p>
<p>超时重传的时间设置的太短，会引起很多报文的不必要重传；<br>时间设置的过长，又会使网络的空闲时间增大，降低传输效率；<br>TCP采用了一种自适应算法，它记录一个报文发出的时间，以及收到相应确认的时间，者两个时间之差就是报文的往返时间RTT；<br>最理想的情况下，找到一个最小的时间，保证确认应答一定能在这个时间内返回<br>Linux中，超时以500s为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍；如果重发一次仍然得不到应答，等待2<em>500ms后再进行重传；如果仍然得不到应答，等待4</em>500ms进行重传，依次类推，以指数形式递增;累积到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接。</p>
<h4 id="连接管理机制"><a href="#连接管理机制" class="headerlink" title="连接管理机制"></a>连接管理机制</h4><p>TCP是面向连接的，进行可靠性传输</p>
<h4 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h4><p>让发送方的发送速率不要太快</p>
<p>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
<p>流量控制的实现方法：接收端将自己可接受的缓冲区大小放入TCP首部中的”窗口大小字段”，通过ACK通知发送端；窗口大小字段越大，说明网络的吞吐量越高；接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值给发送端；发送端接受到这个窗口之后，就会减慢自己的发送速率；如果接受缓冲区满了，就会将窗口设置为0，这时发送方不在发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端。</p>
<p>接收方有即时窗口（滑动窗口），随ACK报文发送</p>
<ul>
<li>数据包在传送过程中丢失了<br>当发送端的某一段报文丢失后，发送端会一直收到1001这样的ACK；如果发送端主机连续三次收到同样的”1001”这样的应答，就会将对应的数据1001-2000重新发送；当成功接收到1001之后，再次返回的ACK就是6001了，接收端在之前就已经收到（2001-7000）了，被放到了接收端操作系统内核的接受缓冲区中。这种机制被称作快重传</li>
<li>数据包已经递达，ACK丢了<br>部分ACK丢失了不要紧，因为可以通过后续的ACK进行确认。</li>
</ul>
<h4 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a>拥塞控制：</h4><p>当网络拥塞时，减少数据的发送。</p>
<p>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p>
<p>慢启动、拥塞避免、拥塞发送、快速恢复</p>
<p>应用数据被分割成TCP认为最适合发送的数据块。 </p>
<p>TCP的接收端会丢弃重复的数据。 </p>
<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>也是为了实现可靠传输的，它的基本原理就是每发完一个分组就- 停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP的几个状态 (SYN, FIN, ACK, PSH, RST, URG)</p>
<ul>
<li>SYN表示建立连接，</li>
<li>FIN表示关闭连接，</li>
<li>ACK表示响应</li>
</ul>
<h4 id="TCP四次握手"><a href="#TCP四次握手" class="headerlink" title="TCP四次握手"></a>TCP四次握手</h4><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h3 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="报文构成"><a href="#报文构成" class="headerlink" title="报文构成"></a>报文构成</h3><ul>
<li>请求方法  </li>
<li>请求url</li>
<li>HTTP版本和协议 </li>
<li>报文头部</li>
<li>报文体</li>
</ul>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul>
<li>状态行（HTTP版本 状态码 状态码原因）响应头部</li>
<li>响应内容</li>
</ul>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><ul>
<li>1开头：信息状态码</li>
<li>2开头：成功状态码 </li>
<li>3开头：重定向状态码</li>
<li>4开头：客户端错误状态码 403 服务端收到请求单拒绝提供请求</li>
<li><p>5开头：服务端错误状态码 </p>
<h3 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h3></li>
<li><p>HTTP 1.1支持长连接和请求的流水线处理。HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p>
</li>
<li>HTTP 1.1增加host字段</li>
<li>节约带宽</li>
</ul>
<h3 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h3><ul>
<li>https协议需要申请证书</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http端口(80),https端口(443)。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议更加安全</li>
</ul>
<h4 id="https-优点-缺点"><a href="#https-优点-缺点" class="headerlink" title="https 优点 缺点"></a>https 优点 缺点</h4><ul>
<li>安全</li>
<li>可以认证用户和服务器，确保数据发送倒正确的用户上。</li>
<li>握手延迟高</li>
<li>部署成本高</li>
</ul>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ul>
<li>GET 通过URL 传递，POST放在request body</li>
<li>GET长度有限制</li>
<li>GET更不安全</li>
<li>GET只能进行URL编码，POST支持多种编码方式。</li>
<li>GET请求回浏览器主动Cache ，而POST 支持多组编码方式</li>
<li>GET 请求参数回完整保留在浏览历史记录里，POST不会被保留</li>
<li>本质都是TCP，链接</li>
<li>GET产生一个TCP数据包，POST产生两个数据包</li>
</ul>
<h2 id="IP-MAC地址"><a href="#IP-MAC地址" class="headerlink" title="IP MAC地址"></a>IP MAC地址</h2><ul>
<li>MAC是硬件地址,用来定位网络设备的位置的，主要有数据链路层负责。而IP地址是IP协议提供的统一地址格式，为互联网上每个网络和每一台主机分配一个逻辑地址以此来屏蔽物理地址的差异。</li>
</ul>
<h3 id="TCP-IP-数据链路交互过程。"><a href="#TCP-IP-数据链路交互过程。" class="headerlink" title="TCP/IP 数据链路交互过程。"></a>TCP/IP 数据链路交互过程。</h3><p>网络层等数据链蹭用mac地址作为通信目标，数据包达到网络等准备往数据链路层层发送的时候，首先会去自己的ARP缓存标，寻找目标IP的目标地址，就将IP的mac底池封装倒链路层数据保的包头。如果缓存没找找到，就会发起广播，所有收到广播的机器看这个IP是不是自己的，则以单ba的形式将自己MAC地址回复给请求的机器。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="与mongodb-数据库"><a href="#与mongodb-数据库" class="headerlink" title="与mongodb 数据库"></a>与mongodb 数据库</h3><ul>
<li>内存管理机制上，redis 全部存在内存，定期写入磁盘，当内存不够选择指定的LRU算法删除数据。MongoDB数据存在内存，由Linux 系统map实习，内存不够将热点放入内存其他存在磁盘。</li>
<li>支持的数据结构 HASH SET LIST</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>字符串</li>
<li>列表</li>
<li>哈希</li>
<li>集合</li>
<li>有序集合</li>
</ul>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="虚函数以及多态"><a href="#虚函数以及多态" class="headerlink" title="虚函数以及多态"></a>虚函数以及多态</h2><p>多态的实现主要分为静态多态和动态多态，静态多态，静态多态主要是重装载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。</p>
<p>虚函数的实现：在有虚函数的表中，类的的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际虚函数在代码段。当子类继承了父类的时候也会继承其函数表，当子类重写父类中虚函数时候，会将其继承到虚函数表中的地址替换为原来重新系的函数地址。使用了虚函数会增加访问内存开销，降低效率。</p>
<h2 id="析构函数-虚函数"><a href="#析构函数-虚函数" class="headerlink" title="析构函数 虚函数"></a>析构函数 虚函数</h2><p>基类的析构函数要是虚函数的原因是，如果基类指针指向派生类，基类的析构函数不是虚函数的话，是不会调用派生类的析构函数的，只会调用基类的析构函数</p>
<h2 id="关于虚函数的常见问题"><a href="#关于虚函数的常见问题" class="headerlink" title="关于虚函数的常见问题"></a>关于虚函数的常见问题</h2><h3 id="虚函数的代价"><a href="#虚函数的代价" class="headerlink" title="虚函数的代价"></a>虚函数的代价</h3><p>1）带有虚函数的每个类会产生一个虚函数表，用来存储虚成员函数的指针</p>
<p>2）带有虚函数的每个类都会有一个指向虚函数表的指针</p>
<p>3）不再是内敛函数，因为内敛函数可以在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到达采用哪种函数，所以虚函数不是内敛函数</p>
<h3 id="那些函数不能是虚函数？"><a href="#那些函数不能是虚函数？" class="headerlink" title="那些函数不能是虚函数？"></a>那些函数不能是虚函数？</h3><p>1）构造函数：对象的虚函数表指针需要通过构造函数初始化</p>
<p>2）内联函数：内联函数可以在编译阶段进行函数体的替换，而虚函数需要在运行期间进行确定</p>
<p>3）静态函数：静态函数不属于对象而属于类，因为静态成员函数没有this指针，所以无法访问对象的虚表指针，也就</p>
<p>无法访问类的虚函数表，将静态函数设置成虚函数也就没有任何意义，所以c++语法不支持将静态函数设置成虚函数</p>
<p>4）友元函数：友元函数不属于类，也不能被继承，没有继承特性的函数没有虚函数的说法</p>
<p>5）类外的普通函数：类外普通函数不是类的成员函数，同样不具备继承特性，也就没有虚函数的说法</p>
<h3 id="虚函数和纯虚函数的区别？"><a href="#虚函数和纯虚函数的区别？" class="headerlink" title="虚函数和纯虚函数的区别？"></a>虚函数和纯虚函数的区别？</h3><p>1）纯虚函数只有定义，没有实现，虚函数既有定义，又有实现</p>
<p>2）含有纯虚函数的类不能定义对象，含有虚函数的类可以定义对象</p>
<h3 id="菱形继承的内存结构？如何解决菱形继承存在的问题？"><a href="#菱形继承的内存结构？如何解决菱形继承存在的问题？" class="headerlink" title="菱形继承的内存结构？如何解决菱形继承存在的问题？"></a>菱形继承的内存结构？如何解决菱形继承存在的问题？</h3><p> View Code</p>
<p>1）菱形继承的内存结构：现在有A，B，C，D四个类，B，C分别继承A类，D通过多重继承继承了BC两个类，现在D类中有两个getx()，D类不知道调用哪一个getx()</p>
<p>2）菱形继承的解决办法：虚继承</p>
<p>BC类都用Virtual标注，保证只有一个getx()被创建</p>
<p> View Code</p>
<h3 id="虚析构函数的作用？父类的析构函数为什么一定要设置成虚函数？"><a href="#虚析构函数的作用？父类的析构函数为什么一定要设置成虚函数？" class="headerlink" title="虚析构函数的作用？父类的析构函数为什么一定要设置成虚函数？"></a>虚析构函数的作用？父类的析构函数为什么一定要设置成虚函数？</h3><p>父类虚析构函数就是为了避免内存泄漏，防止子类内存得不到释放造成内存泄漏</p>
<p>1.当父类的析构函数不声明成虚析构函数时，当子类继承父类，父类指针指向子类对象，delete掉父类指针，只会调动父类的析构函数，而不会调用子类的析构函数，从而造成子类对象内存泄漏</p>
<p>2.当父类的析构函数声明成虚析构函数时，当子类继承父类，父类指针指向子类对象，delete掉父类指针，先调动父类的析构函数，然后调用子类的析构函数，不存在子类对象内存泄漏的问题</p>
<p>只要存在继承关系，则父类的虚函数必须定义成虚函数！</p>
<h3 id="构造函数和析构函数中为什么不可以调用虚函数？"><a href="#构造函数和析构函数中为什么不可以调用虚函数？" class="headerlink" title="构造函数和析构函数中为什么不可以调用虚函数？"></a>构造函数和析构函数中为什么不可以调用虚函数？</h3><p>背景知识：</p>
<p>1.构造子类对象时，首先调用父类构造函数初始化对象的父类部分，在执行父类的构造函数时，对象的子类部分都是未初始化的，实际上此时对象还不是一个子类对象</p>
<p>2.析构子类对象时，先析构子类部分，然后按照构造顺序逆序析构父类部分</p>
<p>所以在运行子类的构造和析构函数时，对象都是不完整的，为了适应这种不完整，编译器视对象类型为当前构造或析构函数所在类的类型，由此造成的结构就是：在父类的构造或析构函数中，会将子类对象当作父类对象看待</p>
<p>在这样的背景下</p>
<p>如果我们在父类的构造或析构函数中调用虚函数，调用的往往是当前类的虚函数，达不到多态的效果，跟普通函数调用没有区别</p>
<h3 id="构造函数为什么不能为虚函数？什么情况下析构函数必须为虚函数？"><a href="#构造函数为什么不能为虚函数？什么情况下析构函数必须为虚函数？" class="headerlink" title="构造函数为什么不能为虚函数？什么情况下析构函数必须为虚函数？"></a>构造函数为什么不能为虚函数？什么情况下析构函数必须为虚函数？</h3><p>1）因为虚函数表指针必须在构造函数中初始化，所以构造函数不能为虚函数！</p>
<p>2）当存在继承关系时，父类的析构函数必须为虚函数，这样在父类指针指向子类对象，delete父类指针时，子类对象才不会内存泄漏</p>
<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，以此类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。</p>
<h3 id="字节对齐的细节和编译器实现相关，但一般而言，满足三个准则："><a href="#字节对齐的细节和编译器实现相关，但一般而言，满足三个准则：" class="headerlink" title="字节对齐的细节和编译器实现相关，但一般而言，满足三个准则："></a>字节对齐的细节和编译器实现相关，但一般而言，满足三个准则：</h3><p>1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；<br>2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）<br>3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）</p>
<h2 id="C-中内存泄漏的几种情况"><a href="#C-中内存泄漏的几种情况" class="headerlink" title="C++中内存泄漏的几种情况"></a>C++中内存泄漏的几种情况</h2><ul>
<li>在类的构造函数和析构函数中没有匹配的调用new和delete函数</li>
<li>没有正确地清除嵌套的对象指针 </li>
<li>在释放对象数组时在delete中没有使用方括号</li>
<li>缺少拷贝构造函数</li>
<li>缺少重载赋值运算符</li>
<li>关于nonmodifying运算符重载的常见迷思</li>
<li>没有将基类的析构函数定义为虚函数</li>
</ul>
<h2 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h2><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
<h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void <em> ，需要通过强制类型转换将void</em>指针转换成我们需要的类型。</p>
<h4 id="分配失败"><a href="#分配失败" class="headerlink" title="分配失败"></a>分配失败</h4><p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p>
<h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</p>
<p>malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</p>
<h4 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h4><p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中</p>
<h3 id="左值和右值的区别，右值引用的概念及其应用场景"><a href="#左值和右值的区别，右值引用的概念及其应用场景" class="headerlink" title="左值和右值的区别，右值引用的概念及其应用场景"></a>左值和右值的区别，右值引用的概念及其应用场景</h3><h4 id="左值-lvalue-："><a href="#左值-lvalue-：" class="headerlink" title="左值(lvalue)："></a>左值(lvalue)：</h4><p>非临时性对象的表达式。有名字，可以取地址。如：非匿名对象(包括变量)，函数返回的引用，const对象等都是左值。</p>
<h4 id="右值-rvalue-："><a href="#右值-rvalue-：" class="headerlink" title="右值(rvalue)："></a>右值(rvalue)：</h4><p>临时性对象的表达式，没有名字，临时生成的，不可取地址。如：立即数，函数的返回值。</p>
<h4 id="左右值转换"><a href="#左右值转换" class="headerlink" title="左右值转换"></a>左右值转换</h4><p>右值转化为左值 ：直接新建变量然后赋值就可以了。<br>int b=a+1；将a+1这个右值转变为左值</p>
<p>左值转化为右值： std::move()<br>move (a) ;   将a这个左值转变为了右值</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用本质是指针常量，左值引用只能引用左值。</p>
<p>加 const 就可以常引用</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用绑定到右值，绑定后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。</p>
<p>在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量。但是，唯一 一点的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。</p>
<h4 id="右值引用的用途"><a href="#右值引用的用途" class="headerlink" title="右值引用的用途"></a>右值引用的用途</h4><ul>
<li>避免拷贝，提高性能，实现move()</li>
<li>避免重载参数的复杂性，实现forward()</li>
</ul>
<h2 id="free与delete的区别"><a href="#free与delete的区别" class="headerlink" title="free与delete的区别"></a>free与delete的区别</h2><ol>
<li><p>delete 用于释放 new 分配的空间，free 有用释放 malloc 分配的空间</p>
</li>
<li><p>delete [] 用于释放 new [] 分配的空间</p>
</li>
<li><p>delete 释放空间的时候会调用 相应对象的析构函数</p>
<p> 顺便说一下new在分配空间的时候同时会调用对象的构造函数，对对象进行初始化，使用malloc则只是分配内存</p>
</li>
<li><p>调用free 之前需要检查 需要释放的指针是否为空，使用delete 释放内存则不需要检查指针是否为NULL</p>
</li>
<li><p>free 和 delete 不能混用，也就是说new 分配的内存空间最好不要使用使用free 来释放，malloc 分配的空间也不要使用 delete来释放</p>
</li>
</ol>
<h2 id="堆和栈的区别是什么"><a href="#堆和栈的区别是什么" class="headerlink" title="堆和栈的区别是什么"></a>堆和栈的区别是什么</h2><p>1、堆栈空间分配区别</p>
<p>栈（操作系统）：由操作系统（编译器）自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p>
<p>2、堆栈缓存方式区别</p>
<p>栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。</p>
<p>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
<p>3、堆栈数据结构区别</p>
<p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序。</p>
<p>栈（数据结构）：一种先进后出的数据结构。</p>
<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><p>只能在本$CPP$里面使用。</p>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>多个对象数据共享，安全</p>
<h2 id="cast转换"><a href="#cast转换" class="headerlink" title="cast转换"></a>cast转换</h2><ul>
<li>const_cast 将const 转为非 const</li>
<li>static_cast，隐式转换，用于多态向上转化</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>动态类型转换。用于虚函数的类</p>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>啥都可以转换</p>
<h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><ul>
<li>指针有自己的空间大小是4</li>
<li>可以有const 指针</li>
<li>多级指针</li>
<li>++运算符</li>
<li>返回动态内存分类的对象或者内存必须使用指针<h2 id="virtual关键字的作用"><a href="#virtual关键字的作用" class="headerlink" title="virtual关键字的作用"></a>virtual关键字的作用</h2></li>
<li><p>在派生类中重新定义基类的方法</p>
</li>
<li><p>为多态基类声明virtual析构函数</p>
</li>
<li>抽象基类</li>
</ul>
<h2 id="resize-reserve"><a href="#resize-reserve" class="headerlink" title="resize reserve"></a>resize reserve</h2><ul>
<li>resize:</li>
<li><p>改变最大容量，不会生成元素</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2></li>
<li><p>auto_ptr,share_ptr,weak_ptr，unique_ptr</p>
</li>
</ul>
<p>1) unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能执政可以指向该对象。他对于避免资源泄露（例如“以new创建对象后因为发生异常而忘记调用delect”）特别有用<br>2) shared_ptr 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在最后一个引用被销毁的时候释放。可以查看资源所有个数<br>3) weak_ptr 种一个种不控制对象生命周期的智能指针</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束是忘记释放，造成内存泄漏。使用智能指针可以很大程度上避免这个问题。因为智能指针就是个类，超出了类的作用域，类会自动析构函数，析构函数就会自动释放资源。所有智能指针的就算自动释放内存。</p>
<h2 id="静态函数与虚函数的区别"><a href="#静态函数与虚函数的区别" class="headerlink" title="静态函数与虚函数的区别"></a>静态函数与虚函数的区别</h2><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定，调用回增加一次内存开销。</p>
<h2 id="重载-重写"><a href="#重载-重写" class="headerlink" title="重载 重写"></a>重载 重写</h2><ul>
<li>两个函数名一样，参数不一样</li>
<li>子类继承父类，父类种是虚函数</li>
</ul>
<h2 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h2><p>多态的实现分成静态多态和动态多态</p>
<ul>
<li>静态主要是重载，编译的时候已经确定</li>
<li>动态是用虚函数机制实现，在运行期间动态绑定。</li>
</ul>
<p>例子：一个父类类型的指针指向一个子类对象的时候，使用父类指针去调用子类种重写了的父类中的虚函数，会调用子类重写过后的函数在父类种声明为加了virtual关键子的函数，子类种重写时候不需要加virtual也是虚函数</p>
<p>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数标，表中放了虚函数的地址，实际的虚函数在代码段种。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中的虚函数的时候，会将继承倒虚函数的地址替换为小红鞋写的函数地址，使用虚函数会增加访问内存开销，降低效率。</p>
<h2 id="new-delete-malloc-free-的区别"><a href="#new-delete-malloc-free-的区别" class="headerlink" title="new/delete malloc/free 的区别"></a>new/delete malloc/free 的区别</h2><p>后者必须指明申请内存空间大小，后者对于类，不会调用构造函数 和析构函数</p>
<h2 id="虚函数表具体是怎么实现运行时多态的？"><a href="#虚函数表具体是怎么实现运行时多态的？" class="headerlink" title="虚函数表具体是怎么实现运行时多态的？"></a>虚函数表具体是怎么实现运行时多态的？</h2><p>子类若重写父类虚函数，虚函数表中，函数地址会被替换，对于存在虚函数二点类的对象，在VS种，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p>
<h2 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>是进程的子任务，是CPU调度和分派的基本单位。用于保证程序的实时性，实现了进程内部的并发。</li>
<li>线程是操作系统可识别的最小执行和调度单位。每个线程都肚子占用一个虚拟处理器，独自的寄存器组，指令计数器和处理器状态。</li>
<li>每个线程完成不同的任务，但是共享同一地址空间的。（动态内存，映射文件，目标代码），打开的文件列表和其他内核资源</li>
</ul>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ul>
<li>一个线程只能属于一个进程，一个进程多个线程，依赖关系。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li>
<li>资源分配给进程，同一个进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段，数据段，扩展段。<strong>但是每个线程拥有自己的栈段，（用来存局部变量和临时变量）</strong></li>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>系统开销，在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间。线程切换只需保存或者设置少量寄存器的内容，不涉及存储器管理方面的操作，可见进程的切换开销比较大</li>
<li>通信，线程同步和通信容易实现，需要进程同步和互斥手段的辅助，以保存数据的一致性。在有的系统中线程的<strong>切换，通信，同步</strong> 无须系统内核的干预。</li>
<li>进程编程 简单可靠，创建开销大。</li>
<li>进程不会互相影响。</li>
<li>进程适用与多核，多机分布；线程适用于多核。</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li>最短工作优先（SJF）；</li>
<li>最短剩余时间优先（SRTF）；</li>
<li>最高响应比优先（HRRF）；</li>
<li>优先级调度（Priority）；</li>
<li>轮转调度（RR）。<h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3></li>
<li>管道，系统IPC，套接字</li>
</ul>
<h4 id="普通管道PIPE"><a href="#普通管道PIPE" class="headerlink" title="普通管道PIPE"></a>普通管道PIPE</h4><h4 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h4><h4 id="系统IPC"><a href="#系统IPC" class="headerlink" title="系统IPC"></a>系统IPC</h4><ul>
<li>消息队列</li>
<li>信号量，计数器，用来控制多个进程对共享资源的访问，实现进程兼得互斥和同步。</li>
<li>信号</li>
<li>共享内存</li>
</ul>
<h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h3><ul>
<li>临界区，通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</li>
<li>互斥量 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限</li>
<li>信号量，允许多个线程同时访问一个资源</li>
<li>事件 通知操作的方式来保证多线程同步</li>
</ul>
<h2 id="Linux-虚拟地址空间"><a href="#Linux-虚拟地址空间" class="headerlink" title="Linux 虚拟地址空间"></a>Linux 虚拟地址空间</h2><p>请求分页系统，请求分段系统和请求段页系统都是针对虚拟内存。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>扩大地址空间</li>
<li>内存保护</li>
<li>公平内存分配</li>
<li>当进程通信时，可采用虚拟内存共享的方式实现</li>
<li>当不同的进程使用相同代码时比如库文件中的代码，物理内存中可以存储一分这样的代码，节省内存</li>
<li>虚拟内存很适合在多道程序设计系统中使用，许多程的片段同时保存在内存中，当一个程序等待他的一部分读入内存，可以把CPU交给另一个进程使用。内存中可以保留多个进程，系统的并发度提高</li>
<li>在程序分配连续内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际的物理内存的连续攻击</li>
</ul>
<h2 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h2><ul>
<li>管理的数据结构占用内存</li>
<li>虚拟地址到物理地址的转化，增加了指令的执行时间。</li>
<li>页面的换入还出需要磁盘I/O</li>
<li>一页一部分数据，浪费内存</li>
</ul>
<h2 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发 并行"></a>并发 并行</h2><ul>
<li>并发，运行</li>
<li>并发，交织运行，不能提高性能只能提高效率</li>
<li>并行，严格物理意义上的同时运行，多核CPU，两个程序分别运行在两个核，互不影响</li>
</ul>
<h2 id="OS缺页置换算法"><a href="#OS缺页置换算法" class="headerlink" title="OS缺页置换算法"></a>OS缺页置换算法</h2><ul>
<li>FIFO，置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按进入内存的 先后次序排成队列，从队尾进入，从队首删除。</li>
<li>LRU：置换最近一段时间最长时间未访问的页面。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不可剥夺条件</li>
<li>环路等待条件</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>资源一次性分配</li>
<li>可剥夺资源</li>
<li>资源有序分配法</li>
</ul>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>IO多路复用</p>
<h2 id="TCP和UDP可以同时监听相同的端口吗"><a href="#TCP和UDP可以同时监听相同的端口吗" class="headerlink" title="TCP和UDP可以同时监听相同的端口吗"></a>TCP和UDP可以同时监听相同的端口吗</h2><p>可以</p>
<p>但一台设备里，<br>tcp协议里port号必须有唯一性。<br>同样，<br>udp协议里port号必须有唯一性。</p>
<h2 id="COOKIE和SESSION有什么区别？"><a href="#COOKIE和SESSION有什么区别？" class="headerlink" title="COOKIE和SESSION有什么区别？"></a>COOKIE和SESSION有什么区别？</h2><p>cookie保存在客户端，session保存在服务器端，<br>cookie目的可以跟踪会话，也可以保存用户喜好或者保存用户名密码<br>session用来跟踪会话</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/20/P1084/" rel="next" title="P1084 疫情控制">
                <i class="fa fa-chevron-left"></i> P1084 疫情控制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/31/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E9%A2%98%E8%A7%A3/" rel="prev" title="乱七八糟题解">
                乱七八糟题解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/1.jpg"
                alt="HCN" />
            
              <p class="site-author-name" itemprop="name">HCN</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">270</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/Isaunoya/" title="Isaunoya" target="_blank">Isaunoya</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://sher-wu.github.io/" title="sher-wu" target="_blank">sher-wu</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/Code92007" title="Yzm007" target="_blank">Yzm007</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://dickxyz.github.io/" title="Dick" target="_blank">Dick</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xsxszab.github.io" title="xsxszab" target="_blank">xsxszab</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">1.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OSI"><span class="nav-number">1.1.</span> <span class="nav-text">OSI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入URL之后"><span class="nav-number">1.2.</span> <span class="nav-text">输入URL之后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构建请求"><span class="nav-number">1.2.1.</span> <span class="nav-text">构建请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP"><span class="nav-number">1.3.</span> <span class="nav-text">TCP IP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#区别"><span class="nav-number">1.3.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的可靠连接"><span class="nav-number">1.3.2.</span> <span class="nav-text">TCP的可靠连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#校验和："><span class="nav-number">1.3.2.1.</span> <span class="nav-text">校验和：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#确认应答（ACK）机制："><span class="nav-number">1.3.2.2.</span> <span class="nav-text">确认应答（ACK）机制：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#超时重传："><span class="nav-number">1.3.2.3.</span> <span class="nav-text">超时重传：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接管理机制"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">连接管理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流量控制："><span class="nav-number">1.3.2.5.</span> <span class="nav-text">流量控制：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞控制："><span class="nav-number">1.3.2.6.</span> <span class="nav-text">拥塞控制：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#停止等待协议"><span class="nav-number">1.3.2.7.</span> <span class="nav-text">停止等待协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP三次握手"><span class="nav-number">1.3.3.</span> <span class="nav-text">TCP三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP四次握手"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">TCP四次握手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？"><span class="nav-number">1.3.4.</span> <span class="nav-text">为什么连接的时候是三次握手，关闭的时候却是四次握手？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><span class="nav-number">1.3.5.</span> <span class="nav-text">为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http"><span class="nav-number">1.3.6.</span> <span class="nav-text">http</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">1.4.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#报文构成"><span class="nav-number">1.4.1.</span> <span class="nav-text">报文构成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#响应报文"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">响应报文</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-状态码"><span class="nav-number">1.4.2.</span> <span class="nav-text">HTTP 状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-0和HTTP1-1的区别"><span class="nav-number">1.4.3.</span> <span class="nav-text">HTTP1.0和HTTP1.1的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-和-https-的区别"><span class="nav-number">1.4.4.</span> <span class="nav-text">http 和 https 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#https-优点-缺点"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">https 优点 缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET和POST的区别"><span class="nav-number">1.4.5.</span> <span class="nav-text">GET和POST的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP-MAC地址"><span class="nav-number">1.5.</span> <span class="nav-text">IP MAC地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-数据链路交互过程。"><span class="nav-number">1.5.1.</span> <span class="nav-text">TCP&#x2F;IP 数据链路交互过程。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">2.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redis"><span class="nav-number">2.1.</span> <span class="nav-text">redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与mongodb-数据库"><span class="nav-number">2.1.1.</span> <span class="nav-text">与mongodb 数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">2.1.2.</span> <span class="nav-text">数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number">3.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数以及多态"><span class="nav-number">3.1.</span> <span class="nav-text">虚函数以及多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#析构函数-虚函数"><span class="nav-number">3.2.</span> <span class="nav-text">析构函数 虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于虚函数的常见问题"><span class="nav-number">3.3.</span> <span class="nav-text">关于虚函数的常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数的代价"><span class="nav-number">3.3.1.</span> <span class="nav-text">虚函数的代价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#那些函数不能是虚函数？"><span class="nav-number">3.3.2.</span> <span class="nav-text">那些函数不能是虚函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数和纯虚函数的区别？"><span class="nav-number">3.3.3.</span> <span class="nav-text">虚函数和纯虚函数的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#菱形继承的内存结构？如何解决菱形继承存在的问题？"><span class="nav-number">3.3.4.</span> <span class="nav-text">菱形继承的内存结构？如何解决菱形继承存在的问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚析构函数的作用？父类的析构函数为什么一定要设置成虚函数？"><span class="nav-number">3.3.5.</span> <span class="nav-text">虚析构函数的作用？父类的析构函数为什么一定要设置成虚函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数和析构函数中为什么不可以调用虚函数？"><span class="nav-number">3.3.6.</span> <span class="nav-text">构造函数和析构函数中为什么不可以调用虚函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数为什么不能为虚函数？什么情况下析构函数必须为虚函数？"><span class="nav-number">3.3.7.</span> <span class="nav-text">构造函数为什么不能为虚函数？什么情况下析构函数必须为虚函数？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节对齐"><span class="nav-number">3.4.</span> <span class="nav-text">字节对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字节对齐的细节和编译器实现相关，但一般而言，满足三个准则："><span class="nav-number">3.4.1.</span> <span class="nav-text">字节对齐的细节和编译器实现相关，但一般而言，满足三个准则：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-中内存泄漏的几种情况"><span class="nav-number">3.5.</span> <span class="nav-text">C++中内存泄漏的几种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new和malloc的区别"><span class="nav-number">3.6.</span> <span class="nav-text">new和malloc的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性"><span class="nav-number">3.6.0.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参数"><span class="nav-number">3.6.0.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回类型"><span class="nav-number">3.6.0.3.</span> <span class="nav-text">返回类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分配失败"><span class="nav-number">3.6.0.4.</span> <span class="nav-text">分配失败</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义类型"><span class="nav-number">3.6.0.5.</span> <span class="nav-text">自定义类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载"><span class="nav-number">3.6.0.6.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存区域"><span class="nav-number">3.6.0.7.</span> <span class="nav-text">内存区域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#左值和右值的区别，右值引用的概念及其应用场景"><span class="nav-number">3.6.1.</span> <span class="nav-text">左值和右值的区别，右值引用的概念及其应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#左值-lvalue-："><span class="nav-number">3.6.1.1.</span> <span class="nav-text">左值(lvalue)：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#右值-rvalue-："><span class="nav-number">3.6.1.2.</span> <span class="nav-text">右值(rvalue)：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#左右值转换"><span class="nav-number">3.6.1.3.</span> <span class="nav-text">左右值转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#左值引用"><span class="nav-number">3.6.2.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#右值引用"><span class="nav-number">3.6.3.</span> <span class="nav-text">右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#右值引用的用途"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">右值引用的用途</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free与delete的区别"><span class="nav-number">3.7.</span> <span class="nav-text">free与delete的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆和栈的区别是什么"><span class="nav-number">3.8.</span> <span class="nav-text">堆和栈的区别是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态函数"><span class="nav-number">3.8.1.</span> <span class="nav-text">静态函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的静态成员"><span class="nav-number">3.8.2.</span> <span class="nav-text">类的静态成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cast转换"><span class="nav-number">3.9.</span> <span class="nav-text">cast转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-cast"><span class="nav-number">3.10.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reinterpret-cast"><span class="nav-number">3.11.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与引用"><span class="nav-number">3.12.</span> <span class="nav-text">指针与引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#virtual关键字的作用"><span class="nav-number">3.13.</span> <span class="nav-text">virtual关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#resize-reserve"><span class="nav-number">3.14.</span> <span class="nav-text">resize reserve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#智能指针"><span class="nav-number">3.15.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态函数与虚函数的区别"><span class="nav-number">3.16.</span> <span class="nav-text">静态函数与虚函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载-重写"><span class="nav-number">3.17.</span> <span class="nav-text">重载 重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数和多态"><span class="nav-number">3.18.</span> <span class="nav-text">虚函数和多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-delete-malloc-free-的区别"><span class="nav-number">3.19.</span> <span class="nav-text">new&#x2F;delete malloc&#x2F;free 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数表具体是怎么实现运行时多态的？"><span class="nav-number">3.20.</span> <span class="nav-text">虚函数表具体是怎么实现运行时多态的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统"><span class="nav-number">4.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用户态与内核态"><span class="nav-number">4.1.</span> <span class="nav-text">用户态与内核态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程的概念"><span class="nav-number">4.2.</span> <span class="nav-text">进程与线程的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">4.2.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">4.2.2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区别-1"><span class="nav-number">4.2.3.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度算法"><span class="nav-number">4.2.4.</span> <span class="nav-text">进程调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信方式"><span class="nav-number">4.2.5.</span> <span class="nav-text">进程间通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#普通管道PIPE"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">普通管道PIPE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命名管道FIFO"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">命名管道FIFO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统IPC"><span class="nav-number">4.2.5.3.</span> <span class="nav-text">系统IPC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程间通信方式"><span class="nav-number">4.2.6.</span> <span class="nav-text">线程间通信方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-虚拟地址空间"><span class="nav-number">4.3.</span> <span class="nav-text">Linux 虚拟地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#好处"><span class="nav-number">4.3.1.</span> <span class="nav-text">好处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代价"><span class="nav-number">4.4.</span> <span class="nav-text">代价</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发-并行"><span class="nav-number">4.5.</span> <span class="nav-text">并发 并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OS缺页置换算法"><span class="nav-number">4.6.</span> <span class="nav-text">OS缺页置换算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">4.7.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#必要条件"><span class="nav-number">4.7.1.</span> <span class="nav-text">必要条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决方法"><span class="nav-number">4.8.</span> <span class="nav-text">解决方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll"><span class="nav-number">4.9.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP和UDP可以同时监听相同的端口吗"><span class="nav-number">4.10.</span> <span class="nav-text">TCP和UDP可以同时监听相同的端口吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#COOKIE和SESSION有什么区别？"><span class="nav-number">4.11.</span> <span class="nav-text">COOKIE和SESSION有什么区别？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HCN</span>

  

</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  
    <span class="site-uv">
      访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
